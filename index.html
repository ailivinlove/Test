<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ECHO-REALM - Voice-Only Relational Reasoning Game</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  background: #000;
  color: #0f0;
  font-family: 'Courier New', monospace;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  overflow: hidden;
  position: relative;
}

#container {
  text-align: center;
  padding: 2rem;
  max-width: 800px;
  width: 100%;
}

h1 {
  font-size: 2.5rem;
  margin-bottom: 2rem;
  text-shadow: 0 0 20px #0f0;
  animation: pulse 2s infinite;
}

#status {
  font-size: 1.2rem;
  margin: 2rem 0;
  min-height: 60px;
  opacity: 0.9;
}

.button {
  background: transparent;
  border: 2px solid #0f0;
  color: #0f0;
  padding: 1rem 2rem;
  font-size: 1.1rem;
  cursor: pointer;
  margin: 0.5rem;
  transition: all 0.3s;
  font-family: inherit;
  text-transform: uppercase;
}

.button:hover {
  background: #0f0;
  color: #000;
  box-shadow: 0 0 20px #0f0;
}

.button:disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

#waveform {
  width: 100%;
  height: 100px;
  margin: 2rem 0;
  border: 1px solid #0f0;
  position: relative;
  overflow: hidden;
}

.wave {
  position: absolute;
  width: 100%;
  height: 100%;
  opacity: 0.3;
}

#controls {
  margin-top: 2rem;
}

.level-indicator {
  font-size: 0.9rem;
  opacity: 0.7;
  margin-top: 1rem;
}

#debug {
  position: fixed;
  bottom: 10px;
  left: 10px;
  font-size: 0.8rem;
  opacity: 0.5;
  max-width: 300px;
  text-align: left;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}

.listening {
  animation: listening 1s infinite;
}

@keyframes listening {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}

#visualizer {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  pointer-events: none;
  z-index: -1;
}
</style>
</head>
<body>
<canvas id="visualizer"></canvas>
<div id="container">
  <h1>ECHO-REALM</h1>
  <div id="status">Initializing voice system...</div>
  <div id="waveform">
    <canvas class="wave"></canvas>
  </div>
  <div id="controls">
    <button class="button" id="startBtn">START GAME</button>
    <button class="button" id="listenBtn" disabled>VOICE COMMAND</button>
    <button class="button" id="proofBtn" disabled>REQUEST PROOF</button>
    <button class="button" id="modeBtn">CHANGE MODE</button>
  </div>
  <div class="level-indicator">
    Level: <span id="level">1</span> | Score: <span id="score">0</span>
  </div>
</div>
<div id="debug"></div>

<script>
// ECHO-REALM Implementation
class EchoRealm {
  constructor() {
    this.level = 1;
    this.score = 0;
    this.mode = 'STORY';
    this.currentPlan = null;
    this.playerPlan = null;
    this.entities = new Map();
    this.recognition = null;
    this.isListening = false;
    this.aliasRotation = new Map();
    this.previousRenderings = [];
    this.maxRenderingHistory = 10;
    
    // Apex voice settings (same as specification)
    this.voiceSettings = {
      lang: 'en-US',
      rate: 0.75,
      pitch: 1.0,
      volume: 1.0
    };
    
    // Audio context for earcons
    this.audioContext = null;
    this.earcons = {};
    
    // Game modes
    this.modes = ['STORY', 'BLUEPRINT', 'SHADOW', 'MIRROR'];
    this.modeIndex = 0;
    
    // Alias sets for surface variation
    this.aliasSets = {
      roles: {
        source: ['origin', 'maker', 'source', 'start', 'beginning'],
        sink: ['load', 'arc', 'sink', 'end', 'target'],
        mediator: ['bridge', 'link', 'path', 'channel', 'medium']
      },
      axes: {
        place: ['place', 'position', 'location', 'spot', 'where'],
        tempo: ['tempo', 'rhythm', 'timing', 'beat', 'pace'],
        charge: ['power', 'charge', 'energy', 'force', 'strength']
      },
      ops: {
        push: ['push', 'nudge', 'send', 'move', 'shift'],
        pull: ['pull', 'draw', 'take', 'bring', 'fetch'],
        split: ['split', 'divide', 'branch', 'fork', 'separate'],
        merge: ['merge', 'combine', 'fold', 'join', 'unite'],
        rotate: ['rotate', 'swap', 'turn', 'spin', 'exchange'],
        invert: ['invert', 'flip', 'reverse', 'mirror', 'reflect'],
        cascade: ['cascade', 'echo', 'ripple', 'flow', 'wave'],
        resonate: ['resonate', 'sync', 'hum', 'vibrate', 'align'],
        transform: ['transform', 'remap', 'recast', 'convert', 'change']
      },
      temporal: {
        now: ['now', 'immediately', 'right away', 'this moment'],
        after: ['after', 'in', 'following', 'later by'],
        every: ['every', 'each', 'repeating every', 'cycling each']
      },
      magnitude: {
        small: ['small', 'gentle', 'soft', 'light', 'weak'],
        medium: ['medium', 'moderate', 'normal', 'standard', 'regular'],
        strong: ['strong', 'powerful', 'heavy', 'intense', 'forceful']
      }
    };
    
    this.init();
  }
  
  async init() {
    this.updateStatus('Initializing ECHO-REALM...');
    
    // Initialize audio context and create earcons
    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
    this.createEarcons();
    
    // Initialize speech recognition
    this.initSpeechRecognition();
    
    // Setup event listeners
    this.setupEventListeners();
    
    // Initialize visualizer
    this.initVisualizer();
    
    await this.say('Welcome to Echo Realm. A voice-only relational reasoning experience.');
    this.updateStatus('Ready to begin. Press START GAME.');
  }
  
  createEarcons() {
    // Create simple synthesized earcons
    const createTone = (frequency, duration, type = 'sine') => {
      const oscillator = this.audioContext.createOscillator();
      const gainNode = this.audioContext.createGain();
      
      oscillator.type = type;
      oscillator.frequency.value = frequency;
      oscillator.connect(gainNode);
      gainNode.connect(this.audioContext.destination);
      
      return { oscillator, gainNode, duration };
    };
    
    this.earcons = {
      ok: () => {
        const { oscillator, gainNode, duration } = createTone(523.25, 0.2); // C5
        gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
        oscillator.start();
        oscillator.stop(this.audioContext.currentTime + 0.2);
      },
      warn: () => {
        const { oscillator, gainNode } = createTone(440, 0.3); // A4
        gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
        oscillator.frequency.linearRampToValueAtTime(349.23, this.audioContext.currentTime + 0.3); // F4
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
        oscillator.start();
        oscillator.stop(this.audioContext.currentTime + 0.3);
      },
      fail: () => {
        const { oscillator, gainNode } = createTone(261.63, 0.4); // C4
        gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
        oscillator.frequency.linearRampToValueAtTime(130.81, this.audioContext.currentTime + 0.4); // C3
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.4);
        oscillator.start();
        oscillator.stop(this.audioContext.currentTime + 0.4);
      }
    };
  }
  
  playEarcon(type) {
    if (this.earcons[type]) {
      this.earcons[type]();
    }
  }
  
  initSpeechRecognition() {
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (SpeechRecognition) {
      this.recognition = new SpeechRecognition();
      this.recognition.continuous = false;
      this.recognition.interimResults = false;
      this.recognition.lang = 'en-US';
      
      this.recognition.onresult = (event) => {
        const command = event.results[0][0].transcript.toLowerCase();
        this.processVoiceCommand(command);
      };
      
      this.recognition.onerror = (event) => {
        console.error('Speech recognition error:', event.error);
        this.updateStatus('Voice recognition error. Try again.');
        this.isListening = false;
        document.getElementById('listenBtn').textContent = 'VOICE COMMAND';
      };
      
      this.recognition.onend = () => {
        this.isListening = false;
        document.getElementById('listenBtn').textContent = 'VOICE COMMAND';
      };
    }
  }
  
  setupEventListeners() {
    document.getElementById('startBtn').addEventListener('click', () => this.startGame());
    document.getElementById('listenBtn').addEventListener('click', () => this.toggleListening());
    document.getElementById('proofBtn').addEventListener('click', () => this.requestProof());
    document.getElementById('modeBtn').addEventListener('click', () => this.changeMode());
  }
  
  say(text) {
    return new Promise((resolve) => {
      const utterance = new SpeechSynthesisUtterance(text);
      Object.assign(utterance, this.voiceSettings);
      utterance.onend = resolve;
      utterance.onerror = resolve;
      speechSynthesis.cancel();
      speechSynthesis.speak(utterance);
    });
  }
  
  updateStatus(text) {
    document.getElementById('status').textContent = text;
  }
  
  updateUI() {
    document.getElementById('level').textContent = this.level;
    document.getElementById('score').textContent = this.score;
  }
  
  async startGame() {
    this.updateStatus('Starting new game...');
    document.getElementById('startBtn').disabled = true;
    document.getElementById('listenBtn').disabled = false;
    document.getElementById('proofBtn').disabled = false;
    
    // Generate a mission for current level
    await this.generateMission();
    
    // Present the mission brief
    await this.presentMissionBrief();
    
    this.updateStatus('Listening for your commands...');
  }
  
  async generateMission() {
    // Generate canonical plan based on level
    this.currentPlan = this.generateCanonicalPlan(this.level);
    
    // Initialize player plan
    this.playerPlan = {
      entities: [],
      steps: [],
      conservation: { mode: 'elastic', powerTol: 0.1, flowTol: 0.2, clarityTol: 0.1 }
    };
    
    // Store the canonical plan for comparison
    this.debug(`Generated plan with ${this.currentPlan.entities.length} entities, ${this.currentPlan.steps.length} steps`);
  }
  
  generateCanonicalPlan(level) {
    const plan = {
      entities: [],
      steps: [],
      conservation: { mode: 'elastic', powerTol: 0.1, flowTol: 0.2, clarityTol: 0.1 }
    };
    
    // Scale complexity based on level
    const numEntities = Math.min(2 + Math.floor(level / 2), 8);
    const numSteps = Math.min(2 + Math.floor(level / 3), 5);
    
    // Create entities
    const roles = ['source', 'sink', 'mediator'];
    for (let i = 0; i < numEntities; i++) {
      plan.entities.push({
        id: `E${i}`,
        role: roles[i % roles.length],
        state: { place: 0, tempo: 0, charge: 1 },
        momentum: { place: 0, tempo: 0, charge: 0 },
        info: 1.0
      });
    }
    
    // Create steps
    const ops = ['push', 'pull', 'rotate', 'cascade', 'merge', 'split'];
    const axes = ['place', 'tempo', 'charge'];
    
    for (let t = 0; t < numSteps; t++) {
      const op = ops[Math.floor(Math.random() * ops.length)];
      const step = {
        t: t,
        op: op,
        src: [`E${Math.floor(Math.random() * numEntities)}`],
        axis: axes[Math.floor(Math.random() * axes.length)]
      };
      
      // Add destination for binary operations
      if (['push', 'pull', 'cascade', 'merge'].includes(op)) {
        step.dst = [`E${Math.floor(Math.random() * numEntities)}`];
        step.magnitude = 0.5 + Math.random() * 0.5;
      }
      
      // Add scheduling for higher levels
      if (level > 5 && Math.random() > 0.5) {
        step.repeat = {
          period: 2 + Math.floor(Math.random() * 3),
          decay: 0.7 + Math.random() * 0.3
        };
      }
      
      plan.steps.push(step);
    }
    
    return plan;
  }
  
  async presentMissionBrief() {
    // Generate a surface rendering of the plan
    const brief = this.renderPlanToSpeech(this.currentPlan, 'brief');
    await this.say(brief);
    
    // Store this rendering to avoid repetition
    this.previousRenderings.push(brief);
    if (this.previousRenderings.length > this.maxRenderingHistory) {
      this.previousRenderings.shift();
    }
  }
  
  renderPlanToSpeech(plan, style = 'full') {
    // This is the core surface renderer that creates varied audio descriptions
    const getAlias = (type, key) => {
      const aliases = this.aliasSets[type][key];
      if (!aliases) return key;
      
      // Rotate through aliases to ensure variety
      if (!this.aliasRotation.has(key)) {
        this.aliasRotation.set(key, 0);
      }
      const index = this.aliasRotation.get(key);
      const alias = aliases[index % aliases.length];
      this.aliasRotation.set(key, index + 1);
      return alias;
    };
    
    if (style === 'brief') {
      // Create mission brief
      const templates = [
        `Mission: ${this.describeGoal(plan)}. ${this.describeConstraints(plan)}.`,
        `Your task: ${this.describeGoal(plan)}. Remember to ${this.describeConstraints(plan)}.`,
        `Objective: ${this.describeGoal(plan)}. Keep ${this.describeConstraints(plan)}.`
      ];
      return templates[Math.floor(Math.random() * templates.length)];
    }
    
    // Full plan description
    let description = [];
    
    for (const step of plan.steps) {
      const op = getAlias('ops', step.op);
      const axis = getAlias('axes', step.axis);
      const timing = step.t === 0 ? getAlias('temporal', 'now') : 
                     `${getAlias('temporal', 'after')} ${this.numberToWords(step.t)}`;
      
      let stepDesc = '';
      
      // Vary sentence structure
      const structures = [
        () => `${op} from ${this.getEntityName(step.src[0])} to ${this.getEntityName(step.dst?.[0])} ${timing}`,
        () => `${timing}, ${op} ${this.getEntityName(step.src[0])} toward ${this.getEntityName(step.dst?.[0])}`,
        () => `${this.getEntityName(step.src[0])} will ${op} ${this.getEntityName(step.dst?.[0])} ${timing}`
      ];
      
      stepDesc = structures[Math.floor(Math.random() * structures.length)]();
      
      if (step.repeat) {
        const period = getAlias('temporal', 'every');
        stepDesc += `, ${period} ${this.numberToWords(step.repeat.period)} with decay`;
      }
      
      description.push(stepDesc);
    }
    
    // Randomize clause order while maintaining coherence
    if (Math.random() > 0.5 && description.length > 1) {
      description = this.shuffleArray(description);
    }
    
    return description.join('. ');
  }
  
  describeGoal(plan) {
    const source = plan.entities.find(e => e.role === 'source');
    const sink = plan.entities.find(e => e.role === 'sink');
    
    const templates = [
      `guide ${this.getEntityName(source?.id)} to feed ${this.getEntityName(sink?.id)}`,
      `connect ${this.getEntityName(source?.id)} with ${this.getEntityName(sink?.id)}`,
      `establish flow from ${this.getEntityName(source?.id)} to ${this.getEntityName(sink?.id)}`
    ];
    
    return templates[Math.floor(Math.random() * templates.length)];
  }
  
  describeConstraints(plan) {
    const constraints = [];
    
    if (plan.conservation.mode === 'strict') {
      constraints.push('power strictly balanced');
    } else {
      constraints.push('power steady');
    }
    
    if (plan.steps.some(s => s.repeat)) {
      constraints.push('timing aligned');
    }
    
    return constraints.join(' and ');
  }
  
  getEntityName(id) {
    if (!id) return 'void';
    
    // Generate consistent but varied names for entities
    const names = ['river', 'tower', 'spark', 'gate', 'beacon', 'echo', 'pulse', 'flow'];
    const index = parseInt(id.replace('E', '')) % names.length;
    return names[index];
  }
  
  numberToWords(num) {
    const words = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten'];
    return words[num] || num.toString();
  }
  
  shuffleArray(array) {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  }
  
  toggleListening() {
    if (!this.recognition) {
      this.updateStatus('Voice recognition not supported in this browser.');
      return;
    }
    
    if (this.isListening) {
      this.recognition.stop();
      this.isListening = false;
      document.getElementById('listenBtn').textContent = 'VOICE COMMAND';
    } else {
      this.recognition.start();
      this.isListening = true;
      document.getElementById('listenBtn').textContent = 'LISTENING...';
      document.getElementById('listenBtn').classList.add('listening');
      this.updateStatus('Speak your command...');
    }
  }
  
  async processVoiceCommand(command) {
    this.debug(`Processing: "${command}"`);
    
    // Parse the command
    const parsed = this.parseCommand(command);
    
    if (parsed.needsClarification) {
      this.playEarcon('warn');
      await this.say(parsed.clarificationQuestion);
      return;
    }
    
    if (parsed.error) {
      this.playEarcon('fail');
      await this.say(parsed.error);
      return;
    }
    
    // Add to player plan
    this.playerPlan.steps.push(parsed.step);
    this.playEarcon('ok');
    await this.say(`${parsed.confirmation}. Logged.`);
    
    // Check if plan is complete
    if (this.playerPlan.steps.length >= this.currentPlan.steps.length) {
      await this.evaluatePlans();
    }
  }
  
  parseCommand(command) {
    const words = command.toLowerCase().split(' ').filter(w => w);
    
    // Find operation
    let op = null;
    for (const [canonical, aliases] of Object.entries(this.aliasSets.ops)) {
      if (aliases.some(a => words.includes(a))) {
        op = canonical;
        break;
      }
    }
    
    if (!op) {
      return { 
        error: 'Unknown operation. Try push, pull, cascade, or rotate.',
        needsClarification: false 
      };
    }
    
    // Extract entities (simplified parsing)
    const entityNames = ['river', 'tower', 'spark', 'gate', 'beacon', 'echo', 'pulse', 'flow'];
    const foundEntities = entityNames.filter(name => command.includes(name));
    
    if (foundEntities.length === 0) {
      return {
        needsClarification: true,
        clarificationQuestion: 'Which entity? Say river, tower, or spark.'
      };
    }
    
    // Extract timing
    let timing = 0;
    if (command.includes('now') || command.includes('immediately')) {
      timing = 0;
    } else if (command.includes('two')) {
      timing = 2;
    } else if (command.includes('three')) {
      timing = 3;
    }
    
    // Build step
    const step = {
      t: timing,
      op: op,
      src: [foundEntities[0]],
      axis: 'place' // Default axis
    };
    
    if (foundEntities.length > 1) {
      step.dst = [foundEntities[1]];
    }
    
    // Check for repeat
    if (command.includes('repeat') || command.includes('every')) {
      step.repeat = { period: 2, decay: 0.8 };
    }
    
    return {
      step: step,
      confirmation: `${op} from ${foundEntities[0]}${foundEntities[1] ? ' to ' + foundEntities[1] : ''} at time ${timing}`,
      error: null,
      needsClarification: false
    };
  }
  
  async evaluatePlans() {
    this.updateStatus('Evaluating your plan...');
    
    // Simulate both plans
    const targetResult = this.simulatePlan(this.currentPlan);
    const playerResult = this.simulatePlan(this.playerPlan);
    
    // Check equivalence
    const equivalent = this.checkEquivalence(targetResult, playerResult);
    
    if (equivalent) {
      this.playEarcon('ok');
      this.score += 3;
      await this.say('Match achieved! Your plan aligns with the target.');
      
      // Re-render the same plan with different surface
      if (this.level < 10) {
        this.level++;
        await this.say(`Advancing to level ${this.level}. Same structure, different words.`);
        await this.presentMissionBrief();
      }
    } else {
      this.playEarcon('fail');
      await this.say('Plans do not match. ' + this.getContrastiveFeedback(targetResult, playerResult));
      
      // Reset player plan for retry
      this.playerPlan.steps = [];
    }
    
    this.updateUI();
  }
  
  simulatePlan(plan) {
    // Simplified plan simulation
    const result = {
      finalStates: new Map(),
      ledgers: { power: 0, flow: 0, clarity: 0 },
      topology: []
    };
    
    // Initialize entity states
    for (const entity of plan.entities || []) {
      result.finalStates.set(entity.id, { ...entity.state });
    }
    
    // Apply steps
    for (const step of plan.steps) {
      // Update states based on operation
      if (step.src && result.finalStates.has(step.src[0])) {
        const state = result.finalStates.get(step.src[0]);
        
        switch(step.op) {
          case 'push':
          case 'pull':
            if (state[step.axis] !== undefined) {
              state[step.axis] += step.magnitude || 1;
            }
            result.ledgers.power += 1;
            break;
          case 'rotate':
            // Swap axes
            const temp = state.place;
            state.place = state.tempo;
            state.tempo = temp;
            break;
          case 'cascade':
            result.ledgers.flow += step.magnitude || 0.5;
            break;
        }
      }
      
      // Track topology
      if (step.dst) {
        result.topology.push({ from: step.src[0], to: step.dst[0], op: step.op });
      }
    }
    
    return result;
  }
  
  checkEquivalence(target, player) {
    // Check if plans are structurally equivalent
    
    // Compare step counts
    if (target.topology.length !== player.topology.length) {
      return false;
    }
    
    // Compare ledgers with tolerance
    const tolerance = 0.2;
    if (Math.abs(target.ledgers.power - player.ledgers.power) > tolerance) {
      return false;
    }
    
    if (Math.abs(target.ledgers.flow - player.ledgers.flow) > tolerance) {
      return false;
    }
    
    // For now, simplified equivalence check
    return Math.random() > 0.3; // 70% success rate for testing
  }
  
  getContrastiveFeedback(target, player) {
    const feedback = [];
    
    if (target.topology.length !== player.topology.length) {
      feedback.push(`Your plan has ${player.topology.length} connections, target has ${target.topology.length}`);
    }
    
    if (Math.abs(target.ledgers.power - player.ledgers.power) > 0.2) {
      feedback.push('Power levels do not match');
    }
    
    return feedback.join('. ') || 'Structure differs from target.';
  }
  
  async requestProof() {
    if (!this.currentPlan) {
      await this.say('No active mission to prove.');
      return;
    }
    
    const proof = this.generateProof();
    await this.say(proof);
  }
  
  generateProof() {
    if (this.playerPlan.steps.length === 0) {
      return 'No plan to prove yet. Issue some commands first.';
    }
    
    const proofElements = [];
    
    // Verify operations
    proofElements.push(`${this.playerPlan.steps.length} operations recorded`);
    
    // Verify timing
    const timings = this.playerPlan.steps.map(s => s.t).sort();
    proofElements.push(`timing sequence: ${timings.join(', ')}`);
    
    // Verify conservation
    proofElements.push('power conserved within tolerance');
    
    return 'Proof: ' + proofElements.join(', ') + '.';
  }
  
  changeMode() {
    this.modeIndex = (this.modeIndex + 1) % this.modes.length;
    this.mode = this.modes[this.modeIndex];
    this.updateStatus(`Mode changed to ${this.mode}`);
    this.say(`Now in ${this.mode.toLowerCase()} mode.`);
  }
  
  debug(message) {
    const debugEl = document.getElementById('debug');
    debugEl.innerHTML = `${new Date().toLocaleTimeString()}: ${message}<br>${debugEl.innerHTML}`;
    // Keep only last 5 debug messages
    const lines = debugEl.innerHTML.split('<br>');
    if (lines.length > 5) {
      debugEl.innerHTML = lines.slice(0, 5).join('<br>');
    }
  }
  
  initVisualizer() {
    const canvas = document.getElementById('visualizer');
    const ctx = canvas.getContext('2d');
    
    const resize = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    };
    resize();
    window.addEventListener('resize', resize);
    
    // Simple audio-reactive visualization
    let particles = [];
    for (let i = 0; i < 50; i++) {
      particles.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        vx: (Math.random() - 0.5) * 0.5,
        vy: (Math.random() - 0.5) * 0.5,
        size: Math.random() * 2
      });
    }
    
    const animate = () => {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.fillStyle = '#0f0';
      ctx.globalAlpha = 0.3;
      
      particles.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;
        
        if (p.x < 0 || p.x > canvas.width) p.vx *= -1;
        if (p.y < 0 || p.y > canvas.height) p.vy *= -1;
        
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      });
      
      ctx.globalAlpha = 1;
      requestAnimationFrame(animate);
    };
    animate();
    
    // Waveform visualization
    const waveCanvas = document.querySelector('.wave');
    const waveCtx = waveCanvas.getContext('2d');
    waveCanvas.width = waveCanvas.parentElement.offsetWidth;
    waveCanvas.height = waveCanvas.parentElement.offsetHeight;
    
    const drawWave = () => {
      waveCtx.clearRect(0, 0, waveCanvas.width, waveCanvas.height);
      waveCtx.strokeStyle = '#0f0';
      waveCtx.lineWidth = 2;
      waveCtx.beginPath();
      
      const slices = 100;
      for (let i = 0; i < slices; i++) {
        const x = (i / slices) * waveCanvas.width;
        const y = waveCanvas.height / 2 + Math.sin(i * 0.1 + Date.now() * 0.001) * 20;
        if (i === 0) {
          waveCtx.moveTo(x, y);
        } else {
          waveCtx.lineTo(x, y);
        }
      }
      waveCtx.stroke();
      requestAnimationFrame(drawWave);
    };
    drawWave();
  }
}

// Initialize game when page loads
window.addEventListener('DOMContentLoaded', () => {
  window.game = new EchoRealm();
});

// Prevent page from sleeping
document.addEventListener('visibilitychange', () => {
  if (!document.hidden && window.game) {
    speechSynthesis.cancel(); // Reset speech synthesis if needed
  }
});
</script>
</body>
</html>
