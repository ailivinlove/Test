<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Relational Lattice N-Back ‚Äî Infinity Version (Max G-Load)</title>
<style>
:root { --bg:#0b0d10; --fg:#e6fbff; --a:#00ccff; --mut:#8fe7ff; --glow:#00ffff40 }
*{ box-sizing:border-box }
html,body{ height:100%; overflow-x:hidden }
body{ margin:0; background:#0b0d10; color:#e6fbff; font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif }
.wrap{ max-width:1280px; margin:0 auto; padding:16px }
.row{ display:flex; gap:12px; flex-wrap:wrap }
.col{ flex:1 1 360px }
.box{ background:#101418; border:1px solid rgba(0,200,255,.25); border-radius:14px; padding:12px; backdrop-filter:blur(10px) }
.title{ font-weight:800; margin-bottom:6px; letter-spacing:.3px }
.btn{ background:#0b0d10; color:#00ccff; border:1px solid #00ccff; border-radius:10px; padding:10px 14px; font-weight:700; cursor:pointer; transition:all 0.3s }
.btn:hover:not(:disabled){ background:#00ccff20; box-shadow:0 0 15px rgba(0,200,255,.5) }
.btn:disabled{ opacity:.5; cursor:not-allowed }
.btn.instructions{ background:#5f27cd; border-color:#5f27cd; color:#fff }
.btn.instructions:hover{ background:#6c35db; box-shadow:0 0 15px rgba(95,39,205,.6) }
label{ font-size:12px; color:#8fe7ff; display:block; margin:6px 0 }
input[type=range], input[type=number]{ width:100% }
.kbd{ border:1px solid rgba(255,255,255,.25); padding:2px 6px; border-radius:6px; background:#0b0d10; font-size:11px }
.mut{ color:#8fe7ff; font-size:12px }
hr.hr{border:none;border-top:1px solid rgba(0,200,255,.25);margin:8px 0}

#premiseContainer{ 
  margin-top:12px; 
  min-height:140px; 
  background:linear-gradient(135deg, #0e1113, #131619);
  border:1px solid rgba(0,200,255,.25); 
  border-radius:12px; 
  padding:12px; 
  font-size:28px; 
  line-height:2.1; 
  word-break:break-word; 
  font-family:'Courier New',monospace; 
  font-weight:900; 
  letter-spacing:2px;
  position:relative;
  overflow:hidden;
}

#premiseContainer::before{
  content:'';
  position:absolute;
  top:-50%;
  left:-50%;
  width:200%;
  height:200%;
  background:radial-gradient(circle, rgba(0,200,255,0.05) 0%, transparent 70%);
  animation:rotate 20s linear infinite;
  pointer-events:none;
}

@keyframes rotate{ from{transform:rotate(0deg)} to{transform:rotate(360deg)} }

.premise-line{ 
  margin:14px 0; 
  padding:16px; 
  border-left:7px solid rgba(0,200,255,.7); 
  background:linear-gradient(90deg, rgba(0,200,255,.2), rgba(0,200,255,.05)); 
  border-radius:4px; 
  position:relative;
  z-index:1;
}

.premise-number{ 
  position:absolute; 
  left:-40px; 
  top:50%; 
  transform:translateY(-50%); 
  color:#00ccff; 
  font-size:20px; 
  font-weight:bold 
}

.badge{ 
  display:inline-block; 
  padding:2px 8px; 
  border:1px solid rgba(0,200,255,.35); 
  border-radius:999px; 
  font-size:12px; 
  color:#8fe7ff; 
  margin-left:6px 
}

#countdown{ font-weight:800; color:#00ccff }

/* Semantic highlighting for relational elements */
.symbol{ color:#ff6b6b; text-shadow:0 0 14px rgba(255,107,107,.8); font-weight:bold }
.operation{ color:#4ecdc4; text-shadow:0 0 12px rgba(78,205,196,.8) }
.axis{ color:#ffd700; font-weight:bold; text-shadow:0 0 15px rgba(255,215,0,.9) }
.relation{ color:#a55eea; font-weight:900; text-shadow:0 0 16px rgba(165,94,234,.9) }
.compound{ color:#00d2d3; text-shadow:0 0 10px rgba(0,210,211,.7) }
.state{ color:#26de81; text-shadow:0 0 12px rgba(38,222,129,.8) }

.meta-info{ 
  font-size:13px; 
  color:#4a8aff; 
  margin-top:12px; 
  opacity:0.9; 
  font-weight:normal;
  font-family:system-ui;
}

.lattice-state {
  font-size:11px;
  color:#8fe7ff;
  margin-top:8px;
  padding:5px;
  background:rgba(0,0,0,0.3);
  border-radius:5px;
  font-family:monospace;
}

/* Modal for instructions */
.modal{
  display:none;
  position:fixed;
  z-index:1000;
  left:0;
  top:0;
  width:100%;
  height:100%;
  background:rgba(0,0,0,0.8);
  backdrop-filter:blur(5px);
}

.modal-content{
  background:#101418;
  margin:2% auto;
  padding:20px;
  border:2px solid #00ccff;
  border-radius:15px;
  width:90%;
  max-width:900px;
  max-height:90vh;
  overflow-y:auto;
  box-shadow:0 0 30px rgba(0,200,255,.5);
}

.modal-content h2{ color:#00ccff; margin-top:20px }
.modal-content h3{ color:#8fe7ff; margin-top:15px }
.modal-content h4{ color:#a55eea; margin-top:10px }
.modal-content p{ line-height:1.6; color:#e6fbff }
.modal-content .example{
  background:#0b0d10;
  border-left:3px solid #00ccff;
  padding:10px;
  margin:10px 0;
  font-family:'Courier New',monospace;
  font-size:14px;
}
.modal-content .explanation{
  color:#8fe7ff;
  font-style:italic;
  margin-top:5px;
  padding:5px;
  background:rgba(0,200,255,0.1);
  border-radius:3px;
}
.modal-content ul{ line-height:1.8 }
.modal-content li{ margin:5px 0 }

.close{
  color:#00ccff;
  float:right;
  font-size:28px;
  font-weight:bold;
  cursor:pointer;
  transition:color 0.3s;
}
.close:hover{ color:#ff6b6b }

.diagram {
  background:#0b0d10;
  padding:15px;
  margin:10px 0;
  border:1px solid #00ccff;
  border-radius:5px;
  text-align:center;
  font-family:monospace;
}
</style>
</head>
<body>
<div class="wrap">
  <div class="row">
    <div class="col">
      <div class="box">
        <div class="title">Relational Configuration</div>
        <div class="mut" id="diffExplain">Infinity Version ‚Ä¢ Max G-Load: ~0.95+</div>
        <hr class="hr">
        <label>N-Back level: <span id="nVal">1</span></label>
        <input id="nback" type="range" min="1" max="5" step="1" value="1">
        <hr class="hr">
        <label>Statements per trial: <span id="stmtVal">1</span></label>
        <input id="statements" type="range" min="1" max="5" step="1" value="1">
        <div class="mut small">Multiple statements create cascading relational chains</div>
        <hr class="hr">
        <button id="instructionsBtn" class="btn instructions" style="width:100%; margin-top:10px">üìñ How to Play</button>
      </div>
    </div>

    <div class="col">
      <div class="box">
        <div class="title">Timing & Block</div>
        <div class="mut">Solve window: <strong><span id="solveLabel">5.0</span>s</strong> after speaking.</div>
        <label>Solve window (1‚Äì30s): <span id="solveVal">5.0s</span></label>
        <input id="solveWindow" type="range" min="1" max="30" step="0.1" value="5">
        <label>Trials per block: <span id="tVal">200</span></label>
        <input id="trials" type="range" min="20" max="500" step="10" value="200">
        <label>Target match rate: <span id="rVal">25%</span></label>
        <input id="rate" type="range" min="0" max="100" step="1" value="25">
        <label><input id="speakEnabled" type="checkbox" checked> Speak sentences</label>
      </div>
    </div>

    <div class="col">
      <div class="box">
        <div class="title">Controls / Status</div>
        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:6px">
          <button id="start" class="btn">‚ñ∂ Start</button>
          <button id="pause" class="btn" disabled>‚è∏ Pause</button>
          <button id="reset" class="btn" disabled>üîÑ Reset</button>
          <button id="hit" class="btn" disabled>‚úì Match (<span class="kbd">Space</span>)</button>
          <button id="skip" class="btn" disabled>‚è≠ Skip</button>
        </div>
        <div class="mut" style="margin-top:8px">
          Trial <span id="idx">0</span>/<span id="max">200</span>
          <span class="badge">Planned: <span id="ptype">‚Äî</span></span>
          <span class="badge">Actual: <span id="isMatch">‚Äî</span></span>
          <span class="badge">Countdown: <span id="countdown">‚Äî</span></span>
        </div>
        <div class="mut">Correct: <span id="corr">0</span> ‚Ä¢ Errors: <span id="err">0</span></div>
        <div class="mut small" id="modeLine">Infinity Version ‚Ä¢ Max G-Load: ~0.95+ ‚Ä¢ N=1</div>
      </div>
    </div>
  </div>

  <div class="box" style="margin-top:12px">
    <div class="title">Relational Lattice N-Back <span class="badge">5 words exactly</span> <span class="badge">Multi-dimensional tracking</span></div>
    <div id="premiseContainer" aria-live="polite">‚Äî</div>
  </div>
</div>

<!-- Instructions Modal -->
<div id="instructionsModal" class="modal">
  <div class="modal-content">
    <span class="close">&times;</span>
    <h2>üß† Relational Lattice N-Back - Infinity Version</h2>
    
    <p><strong>Maximum cognitive load through multi-dimensional symbol tracking.</strong> Each 5-word premise describes symbols moving through space, affecting each other, and creating cascading chains of relationships.</p>
    
    <h3>Core Concept: The Relational Lattice</h3>
    <p>Imagine symbols (A, B, C, RED, BLUE, etc.) existing in a multi-dimensional space. Each premise moves these symbols and creates relationships between them. You must track:</p>
    <ul>
      <li><strong>Spatial positions:</strong> UP, DOWN, LEFT, RIGHT, IN, OUT</li>
      <li><strong>Temporal states:</strong> NOW, THEN, PAST, FUTURE</li>
      <li><strong>Causal chains:</strong> affecting, triggering, blocking, enabling</li>
      <li><strong>Phase states:</strong> SOLID, LIQUID, GAS, HOT, COLD</li>
    </ul>
    
    <h3>How Matching Works</h3>
    <p>A <strong>MATCH</strong> occurs when the current premise is <em>relationally compatible</em> with the N-back premise across ALL dimensions:</p>
    <ol>
      <li>Symbol positions must be consistent or complementary</li>
      <li>Causal chains must not contradict</li>
      <li>Phase states must be compatible</li>
      <li>Cascading effects must align</li>
    </ol>
    
    <h3>Understanding Premises</h3>
    <div class="example">
      "A moves-UP affecting B DOWN"
    </div>
    <div class="explanation">
      ‚Ä¢ Symbol A moves upward in space<br>
      ‚Ä¢ This movement causes B to move downward<br>
      ‚Ä¢ A causal relationship is established: A ‚Üí B<br>
      ‚Ä¢ Both symbols now have new positions to track
    </div>
    
    <h3>N-Back 1 Example</h3>
    <h4>Single Statement per Trial:</h4>
    <div class="example">
      Trial 1: A moves-UP affecting B DOWN
      Trial 2: B rotates-LEFT triggering C RIGHT
      Trial 3: A shifts-DOWN affecting B UP
    </div>
    <div class="explanation">
      <strong>Decision for Trial 3: MATCH with Trial 2 (1-back)</strong><br>
      Why: Trial 3 shows "A affecting B" with inverted directions compared to Trial 2's setup. The spatial inversion is compatible, and both maintain the A‚ÜíB relationship.
    </div>
    
    <h3>N-Back 2 Example</h3>
    <div class="example">
      Trial 1: RED splits-LEFT enabling BLUE RIGHT
      Trial 2: BLUE merges-UP blocking GREEN DOWN  
      Trial 3: RED fragments-RIGHT enabling BLUE LEFT
    </div>
    <div class="explanation">
      <strong>Decision for Trial 3: MATCH with Trial 1 (2-back)</strong><br>
      Why: Both show "RED enabling BLUE" with complementary spatial inversions (LEFT/RIGHT swapped). The causal relationship is preserved.
    </div>
    
    <h3>Multiple Statements - Cascading Effects</h3>
    <div class="example">
      Trial 1:
        [S1] A moves-UP affecting B DOWN
        [S2] B triggers C LEFT simultaneously
        
      Trial 2:
        [S1] X rotates-IN causing Y OUT
        [S2] Y enables Z RIGHT directly
    </div>
    <div class="explanation">
      Both trials show: First symbol affects second ‚Üí second affects third<br>
      The cascade pattern A‚ÜíB‚ÜíC matches X‚ÜíY‚ÜíZ structurally
    </div>
    
    <h3>Key Concept: Cascading Relationships</h3>
    <div class="diagram">
      If A affects B, and B affects C, then A indirectly affects C
      
      A ‚Üí B ‚Üí C (cascade chain)
         ‚Üì
      A ‚üπ C (indirect effect)
    </div>
    <p>You must track these indirect effects! If a later premise contradicts an indirect effect, it's a NON-MATCH.</p>
    
    <h3>Advanced Example: N-Back 3 with Cascades</h3>
    <div class="example">
      Trial 1: A pushes-UP enabling B DOWN
      Trial 2: B pulls-LEFT blocking C RIGHT
      Trial 3: C grows-IN affecting A OUT
      Trial 4: A drives-DOWN enabling B UP
    </div>
    <div class="explanation">
      <strong>Trial 4 vs Trial 1 (3-back): MATCH</strong><br>
      ‚Ä¢ Both: "A enabling B" with inverted directions<br>
      ‚Ä¢ Cascade check: A‚ÜíB relationship preserved<br>
      ‚Ä¢ No conflicts with C's relationships<br>
      ‚Ä¢ Spatial inversions are compatible
    </div>
    
    <h3>Mental Simulation Strategy</h3>
    <p><strong>For each premise, ask yourself:</strong></p>
    <ol>
      <li>What symbols are involved?</li>
      <li>How does each symbol move/change?</li>
      <li>What relationships are created?</li>
      <li>What indirect effects cascade through the chain?</li>
      <li>Does this conflict with the N-back premise's relationships?</li>
    </ol>
    
    <h3>Common Patterns to Track</h3>
    <ul>
      <li><strong>Spatial inversions:</strong> UP‚ÜîDOWN, LEFT‚ÜîRIGHT are often compatible</li>
      <li><strong>Causal preservation:</strong> "affecting", "enabling", "triggering" relationships must be consistent</li>
      <li><strong>Chain breaks:</strong> If A‚ÜíB‚ÜíC exists, breaking B‚ÜíC breaks the whole chain</li>
      <li><strong>Phase conflicts:</strong> SOLID can't be LIQUID simultaneously</li>
    </ul>
    
    <h3>Why This is Hard</h3>
    <p>You cannot pattern-match words! The same words can create different relationships based on context. You must:</p>
    <ul>
      <li>Mentally simulate each symbol's state</li>
      <li>Track multiple relationships simultaneously</li>
      <li>Compute cascading effects</li>
      <li>Check compatibility across all dimensions</li>
    </ul>
    
    <p><strong>Remember:</strong> This is testing your ability to maintain and manipulate a complex relational model in working memory. Take your time to mentally simulate the full lattice before responding!</p>
  </div>
</div>

<script>
/* ============================================================
   RELATIONAL LATTICE N-BACK - INFINITY VERSION
   Maximum G-Load through Multi-Dimensional Symbol Tracking
   ============================================================ */

const $ = id => document.getElementById(id);
function setText(id,v){ const el=$(id); if(el) el.textContent=v; }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]] } return a; }

/* ===== RELATIONAL LATTICE ENGINE ===== */
class RelationalLattice {
  constructor() {
    // Multi-dimensional axes
    this.axes = {
      spatial: ['UP', 'DOWN', 'LEFT', 'RIGHT', 'IN', 'OUT'],
      temporal: ['NOW', 'THEN', 'PAST', 'FUTURE'],
      causal: ['affecting', 'triggering', 'blocking', 'enabling', 'preventing'],
      phase: ['SOLID', 'LIQUID', 'GAS', 'HOT', 'COLD']
    };
    
    // Track symbol states across all dimensions
    this.symbolStates = new Map();
    
    // Track relationships between symbols
    this.relationships = new Map();
    
    // Track cascading effects
    this.cascades = [];
  }
  
  // Parse premise into components
  parsePremise(premise) {
    const words = premise.split(' ');
    if(words.length !== 5) {
      console.error('Premise must be exactly 5 words:', premise);
      return null;
    }
    
    // Common patterns:
    // "A moves-UP affecting B DOWN"
    // "RED splits-LEFT enabling BLUE RIGHT"
    // "X|Y rotates-IN triggering Z OUT"
    
    const result = {
      primarySymbol: null,
      secondarySymbol: null,
      operation: null,
      primaryAxis: null,
      secondaryAxis: null,
      relation: null
    };
    
    // Extract symbols (uppercase letters or colors)
    const symbols = words.filter(w => /^[A-Z]+$/.test(w) && w.length <= 5);
    result.primarySymbol = symbols[0];
    result.secondarySymbol = symbols[1];
    
    // Extract compound operation (word with hyphen)
    const compound = words.find(w => w.includes('-'));
    if(compound) {
      const parts = compound.split('-');
      result.operation = parts[0];
      result.primaryAxis = parts[1];
    }
    
    // Extract relation (affecting, triggering, etc.)
    for(const word of words) {
      if(this.axes.causal.includes(word)) {
        result.relation = word;
        break;
      }
    }
    
    // Extract secondary axis (remaining spatial/phase word)
    result.secondaryAxis = words[4];
    
    return result;
  }
  
  // Apply transformation to lattice
  applyTransformation(premise) {
    const parsed = this.parsePremise(premise);
    if(!parsed) return;
    
    const {primarySymbol, secondarySymbol, operation, primaryAxis, secondaryAxis, relation} = parsed;
    
    // Update primary symbol state
    if(!this.symbolStates.has(primarySymbol)) {
      this.symbolStates.set(primarySymbol, {
        spatial: {x: 0, y: 0, z: 0},
        temporal: 'NOW',
        phase: 'NEUTRAL',
        energy: 10
      });
    }
    
    const primaryState = this.symbolStates.get(primarySymbol);
    this.applyOperation(primaryState, operation, primaryAxis);
    
    // Create/update relationship
    const relKey = `${primarySymbol}->${secondarySymbol}`;
    this.relationships.set(relKey, {
      type: relation,
      strength: 0.8,
      axis: primaryAxis
    });
    
    // Apply cascading effect to secondary symbol
    if(!this.symbolStates.has(secondarySymbol)) {
      this.symbolStates.set(secondarySymbol, {
        spatial: {x: 0, y: 0, z: 0},
        temporal: 'NOW',
        phase: 'NEUTRAL',
        energy: 10
      });
    }
    
    const secondaryState = this.symbolStates.get(secondarySymbol);
    this.applyCascade(secondaryState, relation, secondaryAxis);
    
    // Check for indirect cascades
    this.computeIndirectEffects(primarySymbol, secondarySymbol);
  }
  
  // Apply operation to symbol state
  applyOperation(state, operation, axis) {
    switch(operation) {
      case 'moves':
      case 'shifts':
        this.applyMovement(state, axis);
        break;
      case 'rotates':
      case 'spins':
        this.applyRotation(state, axis);
        break;
      case 'splits':
      case 'fragments':
        state.energy *= 0.5;
        state.phase = 'FRAGMENTED';
        break;
      case 'merges':
      case 'combines':
        state.energy *= 2;
        state.phase = 'UNIFIED';
        break;
      case 'grows':
      case 'expands':
        state.energy += 3;
        break;
      case 'shrinks':
      case 'contracts':
        state.energy -= 3;
        break;
    }
  }
  
  applyMovement(state, direction) {
    switch(direction) {
      case 'UP': state.spatial.y += 1; break;
      case 'DOWN': state.spatial.y -= 1; break;
      case 'LEFT': state.spatial.x -= 1; break;
      case 'RIGHT': state.spatial.x += 1; break;
      case 'IN': state.spatial.z -= 1; break;
      case 'OUT': state.spatial.z += 1; break;
    }
  }
  
  applyRotation(state, axis) {
    // Rotation swaps coordinates
    const {x, y, z} = state.spatial;
    switch(axis) {
      case 'LEFT':
      case 'RIGHT':
        state.spatial.y = z;
        state.spatial.z = y;
        break;
      case 'UP':
      case 'DOWN':
        state.spatial.x = z;
        state.spatial.z = x;
        break;
      case 'IN':
      case 'OUT':
        state.spatial.x = y;
        state.spatial.y = x;
        break;
    }
  }
  
  // Apply cascading effect based on relationship
  applyCascade(state, relation, axis) {
    switch(relation) {
      case 'affecting':
        this.applyMovement(state, axis);
        break;
      case 'triggering':
        this.applyMovement(state, axis);
        state.temporal = 'THEN';
        break;
      case 'blocking':
        // Inverse movement
        const inverse = this.getInverseAxis(axis);
        this.applyMovement(state, inverse);
        state.energy -= 2;
        break;
      case 'enabling':
        this.applyMovement(state, axis);
        state.energy += 1;
        break;
      case 'preventing':
        // No movement, energy loss
        state.energy -= 3;
        break;
    }
  }
  
  getInverseAxis(axis) {
    const inverses = {
      'UP': 'DOWN', 'DOWN': 'UP',
      'LEFT': 'RIGHT', 'RIGHT': 'LEFT',
      'IN': 'OUT', 'OUT': 'IN'
    };
    return inverses[axis] || axis;
  }
  
  // Compute indirect cascading effects
  computeIndirectEffects(symbol1, symbol2) {
    // Find all symbols affected by symbol2
    for(const [rel, data] of this.relationships.entries()) {
      if(rel.startsWith(`${symbol2}->`)) {
        const symbol3 = rel.split('->')[1];
        
        // Create indirect relationship symbol1 -> symbol3
        const indirectKey = `${symbol1}->>${symbol3}`;
        if(!this.relationships.has(indirectKey)) {
          this.relationships.set(indirectKey, {
            type: 'indirect',
            strength: data.strength * 0.6,
            via: symbol2
          });
          
          this.cascades.push({
            from: symbol1,
            through: symbol2,
            to: symbol3
          });
        }
      }
    }
  }
  
  // Clone current state
  cloneState() {
    const clone = new RelationalLattice();
    
    // Deep copy symbol states
    for(const [symbol, state] of this.symbolStates) {
      clone.symbolStates.set(symbol, {
        spatial: {...state.spatial},
        temporal: state.temporal,
        phase: state.phase,
        energy: state.energy
      });
    }
    
    // Copy relationships
    for(const [rel, data] of this.relationships) {
      clone.relationships.set(rel, {...data});
    }
    
    // Copy cascades
    clone.cascades = [...this.cascades];
    
    return clone;
  }
  
  // Check if two lattice states are compatible
  isCompatibleWith(other) {
    // Check each symbol's state compatibility
    for(const [symbol, state] of this.symbolStates) {
      if(other.symbolStates.has(symbol)) {
        const otherState = other.symbolStates.get(symbol);
        
        // Check phase compatibility
        if(state.phase === 'SOLID' && otherState.phase === 'LIQUID') return false;
        if(state.phase === 'FRAGMENTED' && otherState.phase === 'UNIFIED') return false;
        
        // Check energy conservation
        if(Math.abs(state.energy - otherState.energy) > 5) return false;
      }
    }
    
    // Check relationship compatibility
    for(const [rel, data] of this.relationships) {
      if(other.relationships.has(rel)) {
        const otherData = other.relationships.get(rel);
        
        // Check if relationship types conflict
        if(data.type === 'blocking' && otherData.type === 'enabling') return false;
        if(data.type === 'preventing' && otherData.type === 'triggering') return false;
      }
    }
    
    // Check cascade consistency
    for(const cascade of this.cascades) {
      // Check if cascade is broken in other state
      const direct = `${cascade.from}->${cascade.through}`;
      const indirect = `${cascade.through}->${cascade.to}`;
      
      if(!other.relationships.has(direct) && other.relationships.has(indirect)) {
        // Cascade chain is broken
        return false;
      }
    }
    
    return true;
  }
}

/* ===== PREMISE GENERATOR ===== */
class RelationalPremiseGenerator {
  constructor() {
    // Symbol pools - only common, understandable elements
    this.symbols = {
      letters: ['A', 'B', 'C', 'X', 'Y', 'Z'],
      colors: ['RED', 'BLUE', 'GREEN', 'BLACK', 'WHITE'],
      numbers: ['ONE', 'TWO', 'THREE', 'FOUR', 'FIVE']
    };
    
    // Operations
    this.operations = [
      'moves', 'shifts', 'rotates', 'spins',
      'splits', 'merges', 'grows', 'shrinks',
      'pulls', 'pushes', 'drives', 'flows'
    ];
    
    // Relations (causal)
    this.relations = ['affecting', 'triggering', 'blocking', 'enabling', 'preventing'];
    
    // Spatial axes
    this.spatialAxes = ['UP', 'DOWN', 'LEFT', 'RIGHT', 'IN', 'OUT'];
    
    // Additional descriptors
    this.descriptors = ['directly', 'simultaneously', 'inversely', 'partially'];
    
    // Track used combinations to ensure variety
    this.usedPatterns = new Set();
    this.sessionSeed = Date.now();
  }
  
  // Generate unique random seed
  generateSeed() {
    const sources = [
      Date.now(),
      Math.random() * 1000000,
      performance.now(),
      this.sessionSeed++
    ];
    
    if(window.crypto && window.crypto.getRandomValues) {
      const arr = new Uint32Array(1);
      window.crypto.getRandomValues(arr);
      sources.push(arr[0]);
    }
    
    let hash = 0;
    for(const source of sources) {
      hash = ((hash << 5) - hash) + Math.floor(source);
      hash = hash & hash;
    }
    
    return Math.abs(hash);
  }
  
  // Generate a single 5-word premise
  generatePremise(trial, nback, index = 0) {
    let attempts = 0;
    let premise;
    
    do {
      const seed = this.generateSeed() + attempts;
      premise = this.buildPremise(seed, index);
      attempts++;
    } while(this.usedPatterns.has(premise) && attempts < 50);
    
    this.usedPatterns.add(premise);
    
    // Clear old patterns
    if(this.usedPatterns.size > 100) {
      const patterns = Array.from(this.usedPatterns);
      this.usedPatterns = new Set(patterns.slice(-50));
    }
    
    return premise;
  }
  
  // Build a 5-word relational premise
  buildPremise(seed, index) {
    const pattern = seed % 4;
    
    switch(pattern) {
      case 0:
        // "A moves-UP affecting B DOWN"
        return this.buildPatternAffecting(seed);
      case 1:
        // "RED splits-LEFT enabling BLUE RIGHT"
        return this.buildPatternEnabling(seed);
      case 2:
        // "X rotates-IN triggering Y OUT"
        return this.buildPatternTriggering(seed);
      case 3:
        // "ONE merges-DOWN blocking TWO UP"
        return this.buildPatternBlocking(seed);
    }
  }
  
  buildPatternAffecting(seed) {
    const sym1 = this.getSymbol(seed);
    const op = this.operations[seed % this.operations.length];
    const axis1 = this.spatialAxes[seed % this.spatialAxes.length];
    const sym2 = this.getSymbol(seed + 1);
    const axis2 = this.spatialAxes[(seed + 1) % this.spatialAxes.length];
    
    return `${sym1} ${op}-${axis1} affecting ${sym2} ${axis2}`;
  }
  
  buildPatternEnabling(seed) {
    const sym1 = this.getSymbol(seed, 'colors');
    const op = this.operations[(seed + 2) % this.operations.length];
    const axis1 = this.spatialAxes[(seed + 2) % this.spatialAxes.length];
    const sym2 = this.getSymbol(seed + 1, 'colors');
    const axis2 = this.spatialAxes[(seed + 3) % this.spatialAxes.length];
    
    return `${sym1} ${op}-${axis1} enabling ${sym2} ${axis2}`;
  }
  
  buildPatternTriggering(seed) {
    const sym1 = this.getSymbol(seed, 'letters');
    const op = this.operations[(seed + 1) % this.operations.length];
    const axis1 = this.spatialAxes[(seed + 3) % this.spatialAxes.length];
    const sym2 = this.getSymbol(seed + 2, 'letters');
    const axis2 = this.spatialAxes[(seed + 4) % this.spatialAxes.length];
    
    return `${sym1} ${op}-${axis1} triggering ${sym2} ${axis2}`;
  }
  
  buildPatternBlocking(seed) {
    const sym1 = this.getSymbol(seed, 'numbers');
    const op = this.operations[(seed + 3) % this.operations.length];
    const axis1 = this.spatialAxes[(seed + 1) % this.spatialAxes.length];
    const sym2 = this.getSymbol(seed + 1, 'numbers');
    const axis2 = this.spatialAxes[(seed + 5) % this.spatialAxes.length];
    
    return `${sym1} ${op}-${axis1} blocking ${sym2} ${axis2}`;
  }
  
  getSymbol(seed, type = null) {
    const pools = type ? [this.symbols[type]] : Object.values(this.symbols);
    const pool = pools[seed % pools.length];
    return pool[seed % pool.length];
  }
  
  // Ensure exactly 5 words
  validateWordCount(premise) {
    const words = premise.split(' ').filter(w => w.length > 0);
    return words.length === 5;
  }
}

/* ===== COMPATIBILITY CHECKER ===== */
class CompatibilityChecker {
  constructor() {
    this.lattice = new RelationalLattice();
  }
  
  // Check if two premises match based on relational compatibility
  checkDeepCompatibility(premise1, premise2) {
    // Create two separate lattices
    const lattice1 = new RelationalLattice();
    const lattice2 = new RelationalLattice();
    
    // Apply transformations
    lattice1.applyTransformation(premise1);
    lattice2.applyTransformation(premise2);
    
    // Check compatibility across dimensions
    const checks = {
      spatial: this.checkSpatialCompatibility(lattice1, lattice2),
      causal: this.checkCausalCompatibility(lattice1, lattice2),
      energy: this.checkEnergyConservation(lattice1, lattice2),
      cascade: this.checkCascadeConsistency(lattice1, lattice2)
    };
    
    // Count passing checks
    const passing = Object.values(checks).filter(v => v).length;
    
    // Need at least 3 of 4 dimensions to match
    return passing >= 3;
  }
  
  checkSpatialCompatibility(l1, l2) {
    // Check if spatial transformations are compatible
    for(const [symbol, state1] of l1.symbolStates) {
      if(l2.symbolStates.has(symbol)) {
        const state2 = l2.symbolStates.get(symbol);
        
        // Allow inversions (UP/DOWN, LEFT/RIGHT)
        const dx = Math.abs(state1.spatial.x + state2.spatial.x);
        const dy = Math.abs(state1.spatial.y + state2.spatial.y);
        const dz = Math.abs(state1.spatial.z + state2.spatial.z);
        
        // Compatible if positions are inverse or same
        if(dx > 1 && dy > 1 && dz > 1) return false;
      }
    }
    return true;
  }
  
  checkCausalCompatibility(l1, l2) {
    // Check if causal relationships align
    for(const [rel, data1] of l1.relationships) {
      if(l2.relationships.has(rel)) {
        const data2 = l2.relationships.get(rel);
        
        // Blocking and enabling are incompatible
        if(data1.type === 'blocking' && data2.type === 'enabling') return false;
        if(data1.type === 'enabling' && data2.type === 'blocking') return false;
        if(data1.type === 'preventing' && data2.type === 'triggering') return false;
      }
    }
    return true;
  }
  
  checkEnergyConservation(l1, l2) {
    let totalEnergy1 = 0;
    let totalEnergy2 = 0;
    
    for(const state of l1.symbolStates.values()) {
      totalEnergy1 += state.energy;
    }
    
    for(const state of l2.symbolStates.values()) {
      totalEnergy2 += state.energy;
    }
    
    // Energy should be roughly conserved
    return Math.abs(totalEnergy1 - totalEnergy2) <= 10;
  }
  
  checkCascadeConsistency(l1, l2) {
    // Check if cascade chains are preserved
    for(const cascade of l1.cascades) {
      const chainKey = `${cascade.from}->${cascade.through}`;
      
      // If the chain exists in l2, it should be consistent
      if(l2.relationships.has(chainKey)) {
        const rel2 = l2.relationships.get(chainKey);
        if(rel2.type === 'blocking' || rel2.type === 'preventing') {
          return false; // Chain is broken
        }
      }
    }
    return true;
  }
}

/* ===== Global State ===== */
const premiseGenerator = new RelationalPremiseGenerator();
const compatibilityChecker = new CompatibilityChecker();
let MAX=200, RATE=25, N=1, SPEAK=true, SOLVE_WINDOW=5.0, STATEMENTS=1;

/* ===== Session Management ===== */
let idx=0, correct=0, errors=0, planned=[], history=[], SESSION={running:false, paused:false};
let currentTruth=false, responded=false, solveTimer=null, countdownTimer=null, countdownLeft=0;

function planSequence(){ 
  planned.length=MAX; 
  for(let i=0;i<MAX;i++) planned[i]=false; 
  const elig=[]; 
  for(let i=N;i<MAX;i++) elig.push(i); 
  const k=Math.round((RATE/100)*elig.length); 
  shuffle(elig); 
  for(let i=0;i<k;i++) planned[elig[i]]=true; 
}

function showPremises(premises) {
  const container = $('premiseContainer');
  container.innerHTML = '';
  
  const arr = Array.isArray(premises) ? premises : [premises];
  
  arr.forEach((p, i) => {
    const div = document.createElement('div');
    div.className = 'premise-line';
    
    if(arr.length > 1) {
      const num = document.createElement('span');
      num.className = 'premise-number';
      num.textContent = (i+1).toString();
      div.appendChild(num);
    }
    
    const text = typeof p === 'object' ? p.text : p;
    const words = text.split(' ');
    
    // Style each word appropriately
    words.forEach((word, idx) => {
      const span = document.createElement('span');
      
      if(/^[A-Z]+$/.test(word) && word.length <= 5) {
        // Symbols (letters, colors, numbers)
        if(['RED','BLUE','GREEN','BLACK','WHITE'].includes(word)) {
          span.className = 'symbol';
          span.style.color = word.toLowerCase();
          if(word === 'BLACK') span.style.color = '#666';
          if(word === 'WHITE') span.style.color = '#fff';
        } else if(['ONE','TWO','THREE','FOUR','FIVE'].includes(word)) {
          span.className = 'symbol';
          span.style.color = '#ff00ff';
        } else if(['UP','DOWN','LEFT','RIGHT','IN','OUT'].includes(word)) {
          span.className = 'axis';
        } else {
          span.className = 'symbol';
        }
      } else if(word.includes('-')) {
        // Compound operations
        span.className = 'compound';
      } else if(['affecting','triggering','blocking','enabling','preventing'].includes(word)) {
        // Relations
        span.className = 'relation';
      } else {
        // Other operations
        span.className = 'operation';
      }
      
      span.textContent = word;
      div.appendChild(span);
      
      if(idx < words.length - 1) {
        div.appendChild(document.createTextNode(' '));
      }
    });
    
    // Add lattice state visualization
    if(typeof p === 'object' && p.latticeState) {
      const stateDiv = document.createElement('div');
      stateDiv.className = 'lattice-state';
      stateDiv.textContent = p.latticeState;
      div.appendChild(stateDiv);
    }
    
    container.appendChild(div);
  });
}

function updateUI(){ 
  setText('idx', idx); 
  setText('max', MAX); 
  setText('ptype', (idx<MAX && idx>=N && planned[idx])?'MATCH':'NON-match'); 
  setText('corr', correct); 
  setText('err', errors); 
  setText('isMatch','‚Äî'); 
}

async function speak(text){
  if(!SPEAK) return Promise.resolve();
  if(typeof window==='undefined'||!('speechSynthesis' in window)) return Promise.resolve();
  
  const speakText = Array.isArray(text) ? 
    text.map(p => typeof p === 'object' ? p.text : p).join('. ') : 
    (typeof text === 'object' ? text.text : text);
    
  return new Promise(res=>{ 
    try{ 
      const u=new SpeechSynthesisUtterance(speakText); 
      u.lang='en-GB'; 
      u.rate=0.7; 
      u.pitch=1.0; 
      u.volume=1.0; 
      u.onend=()=>res(); 
      u.onerror=()=>res(); 
      if(window.speechSynthesis.speaking) window.speechSynthesis.cancel(); 
      window.speechSynthesis.speak(u); 
    }catch{ 
      res(); 
    } 
  });
}

function scheduleCountdown(sec){ 
  countdownLeft=sec; 
  setText('countdown', countdownLeft.toFixed(1)+'s'); 
  if(countdownTimer) clearInterval(countdownTimer); 
  countdownTimer=setInterval(()=>{ 
    countdownLeft=Math.max(0,countdownLeft-0.1); 
    setText('countdown', countdownLeft.toFixed(1)+'s'); 
    if(countdownLeft<=0){ 
      clearInterval(countdownTimer); 
      countdownTimer=null; 
    } 
  },100); 
}

function evaluateAndAdvance(){ 
  const resp=responded, truth=currentTruth; 
  if(resp===truth) correct++; 
  else errors++; 
  setText('corr',correct); 
  setText('err',errors); 
  setText('isMatch', String(truth).toUpperCase()); 
  idx++; 
  if(idx>=MAX){ 
    stop(); 
    return; 
  } 
  runTrial(); 
}

function runTrial(){
  if(!SESSION.running || SESSION.paused) return;
  
  const mustMatch=(idx>=N)&&planned[idx];
  
  // Generate premises
  const premises = [];
  for(let i = 0; i < STATEMENTS; i++) {
    const premise = premiseGenerator.generatePremise(idx, N, i);
    
    // Validate word count
    if(!premiseGenerator.validateWordCount(premise)) {
      console.error('Invalid word count:', premise);
    }
    
    premises.push({
      text: premise,
      latticeState: `[Statement ${i+1}]`
    });
  }
  
  // Determine match/non-match
  if(idx >= N) {
    const reference = history[idx-N];
    
    if(mustMatch) {
      // Should be a match
      currentTruth = true;
    } else {
      // Check actual compatibility
      currentTruth = compatibilityChecker.checkDeepCompatibility(
        premises[0].text,
        reference[0].text
      );
      
      // Force non-match if needed
      if(currentTruth) {
        currentTruth = false;
      }
    }
  } else {
    currentTruth = false;
  }
  
  history[idx] = premises;
  showPremises(premises); 
  responded=false;
  
  setText('isMatch','‚Äî'); 
  setText('ptype', (idx<MAX && idx>=N && planned[idx])?'MATCH':'NON-match');

  speak(premises).then(()=>{ 
    scheduleCountdown(SOLVE_WINDOW); 
    if(solveTimer) clearTimeout(solveTimer); 
    solveTimer=setTimeout(()=>{ 
      evaluateAndAdvance(); 
    }, SOLVE_WINDOW*1000); 
  });
}

/* Controls */
function start(){
  MAX=+$('trials').value||200; 
  RATE=+$('rate').value||25; 
  N=+$('nback').value||1; 
  STATEMENTS=+$('statements').value||1;
  SPEAK=!!$('speakEnabled').checked;
  SOLVE_WINDOW=+($('solveWindow').value||5); 
  setText('solveLabel', SOLVE_WINDOW.toFixed(1)); 
  setText('solveVal', SOLVE_WINDOW.toFixed(1)+'s');

  idx=0; 
  correct=0; 
  errors=0; 
  planned=[]; 
  history=[]; 
  planSequence(); 
  updateUI();
  SESSION.running=true; 
  SESSION.paused=false;
  $('pause').disabled=false; 
  $('reset').disabled=false; 
  $('hit').disabled=false; 
  $('skip').disabled=false;
  runTrial();
}

function stop(){ 
  SESSION.running=false; 
  SESSION.paused=false; 
  if(solveTimer) clearTimeout(solveTimer); 
  if(countdownTimer) clearInterval(countdownTimer); 
  setText('countdown','‚Äî'); 
  try{ 
    if(window.speechSynthesis) window.speechSynthesis.cancel(); 
  }catch{} 
}

function togglePause(){
  if(!SESSION.running) return;
  SESSION.paused=!SESSION.paused; 
  $('pause').textContent=SESSION.paused?'‚ñ∂ Resume':'‚è∏ Pause';
  if(SESSION.paused){ 
    if(solveTimer) clearTimeout(solveTimer); 
    if(countdownTimer) clearInterval(countdownTimer); 
    try{ 
      if(window.speechSynthesis) window.speechSynthesis.cancel(); 
    }catch{} 
  }
  else{
    scheduleCountdown(countdownLeft>0?countdownLeft:SOLVE_WINDOW);
    if(solveTimer) clearTimeout(solveTimer);
    solveTimer=setTimeout(()=>{ 
      evaluateAndAdvance(); 
    }, (countdownLeft>0?countdownLeft:SOLVE_WINDOW)*1000);
  }
}

function reset(){ 
  stop(); 
  $('premiseContainer').innerHTML='‚Äî'; 
  setText('idx',0); 
  setText('corr',0); 
  setText('err',0); 
  setText('ptype','‚Äî'); 
  setText('isMatch','‚Äî'); 
}

function registerHit(){ 
  if(!SESSION.running || SESSION.paused) return; 
  responded=true; 
}

function skip(){ 
  if(!SESSION.running || SESSION.paused) return; 
  if(solveTimer) clearTimeout(solveTimer); 
  if(countdownTimer) clearInterval(countdownTimer); 
  setText('countdown','‚Äî'); 
  evaluateAndAdvance(); 
}

/* Event bindings */
document.addEventListener('DOMContentLoaded', ()=>{
  // Instructions modal
  const modal = $('instructionsModal');
  const btn = $('instructionsBtn');
  const span = document.querySelector('.close');
  
  btn.onclick = () => { modal.style.display = 'block'; };
  span.onclick = () => { modal.style.display = 'none'; };
  window.onclick = (e) => {
    if(e.target === modal) modal.style.display = 'none';
  };
  
  // Settings controls
  const sw=$('solveWindow'); 
  const updateSW=()=>{ 
    const v=+sw.value; 
    setText('solveVal', v.toFixed(1)+'s'); 
    setText('solveLabel', v.toFixed(1)); 
  };
  updateSW(); 
  sw.oninput=e=>{ 
    if(!SESSION.running){ 
      updateSW(); 
    } 
  };
  
  $('nback').oninput=e=>{ 
    if(!SESSION.running){ 
      N=+e.target.value; 
      setText('nVal',N); 
      setText('modeLine',`Infinity Version ‚Ä¢ Max G-Load: ~0.95+ ‚Ä¢ N=${N}`);
    } 
  };
  
  $('statements').oninput=e=>{ 
    if(!SESSION.running){ 
      STATEMENTS=+e.target.value; 
      setText('stmtVal',STATEMENTS); 
    } 
  };
  
  $('trials').oninput=e=>{ 
    if(!SESSION.running){ 
      MAX=+e.target.value; 
      setText('tVal',MAX); 
      setText('max',MAX); 
    } 
  };
  
  $('rate').oninput=e=>{ 
    if(!SESSION.running){ 
      RATE=+e.target.value; 
      setText('rVal',RATE+'%'); 
    } 
  };
  
  $('speakEnabled').onchange=e=>{ 
    SPEAK=!!e.target.checked; 
  };

  // Control buttons
  $('start').onclick=start; 
  $('pause').onclick=togglePause; 
  $('reset').onclick=reset; 
  $('hit').onclick=registerHit; 
  $('skip').onclick=skip;
  
  // Keyboard controls
  window.addEventListener('keydown', e=>{ 
    if(!SESSION.running) return; 
    if(e.code==='Space'){ 
      registerHit(); 
      e.preventDefault(); 
    } 
  });

  // Initialize displays
  setText('nVal',N); 
  setText('stmtVal',STATEMENTS);
  setText('tVal',MAX); 
  setText('rVal',RATE+'%');
  setText('modeLine',`Infinity Version ‚Ä¢ Max G-Load: ~0.95+ ‚Ä¢ N=${N}`);
  updateUI();
});
</script>
</body>
</html>
